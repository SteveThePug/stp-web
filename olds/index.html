<html>
  <head>
    <meta charset="utf-8" />
    <title>Playground</title>
    <link rel="icon" type="image/png" href="./img /favicon.png" />
  </head>
  <body>
    <a href="day2.html">
      <canvas id="canvas"></canvas>
    </a>
  </body>
</html>
<script type="module">
  import * as THREE from "three";
  //Universial variables
  const canvas = document.getElementById("canvas");
  const width = canvas.clientWidth;
  const height = canvas.clientHeight;
  var time = 0;

  //Renderer
  const renderer = new THREE.WebGLRenderer({
    canvas: canvas,
    alpha: true,
    antialias: true,
  });
  renderer.setViewport(0, 0, width, height);

  //Textures
  const textures = [];
  const ROWS = 3;
  const COLS = 3;
  const NUM_TEXTURES = COLS * ROWS;
  const loader = new THREE.TextureLoader();
  for (var i = 0; i < NUM_TEXTURES; i++) {
    const texture = loader.load(`./dump/this${i + 1}.jpg`);
    texture.colorSpace = THREE.SRGBColorSpace;
    textures.push(texture);
  }

  //Camera
  const fov = 75;
  const camera = new THREE.PerspectiveCamera(fov, width / height, 0.1, 1000);
  camera.position.set(0, 0, 2);
  const vertical = 2 * Math.atan(fov / 2);
  const horizontal = vertical * (width / height);

  camera.lookAt(new THREE.Vector3(0, 0, 0));

  //Scene
  const scene = new THREE.Scene();

  //Resize to Canvas
  function resizeCanvasToDisplaySize() {
    const canvas = renderer.domElement;
    // look up the size the canvas is being displayed
    const width = canvas.clientWidth;
    const height = canvas.clientHeight;

    // adjust displayBuffer size to match
    if (canvas.width !== width || canvas.height !== height) {
      // you must pass false here or three.js sadly fights the browser
      renderer.setSize(width, height, false);
      camera.aspect = width / height;
      camera.updateProjectionMatrix();

      // update any render target sizes here
    }
  }

  //Books
  const books = [];
  var rowNum = -1;
  for (var i = 0; i < ROWS * COLS; i++) {
    if (i % COLS == 0) rowNum++;
    const geometry = new THREE.BoxGeometry(
      horizontal / COLS,
      vertical / ROWS,
      horizontal / COLS
    );
    const material = new THREE.MeshBasicMaterial({ map: textures[i] });
    const book = new THREE.Mesh(geometry, material);

    book.rotation.y = i / 10;

    book.position.x =
      -horizontal / 2 +
      horizontal / (COLS * 2) +
      (horizontal / COLS) * (i % COLS);
    book.position.y =
      -vertical / 2 + vertical / (ROWS * 2) + (vertical / ROWS) * rowNum;

    books.push(book);
    scene.add(book);
  }

  //Animation
  function animate() {
    resizeCanvasToDisplaySize();
    for (var i = 0; i < COLS * ROWS; i++) {
      books[i].rotation.y += (1 / 300) * (i - 9) + 0.01;
    }
    time += 0.01;
    renderer.render(scene, camera);
    requestAnimationFrame(animate);
  }
  renderer.render(scene, camera);
  animate();
</script>
<style>
  body {
    display: flexbox;
    justify-content: center;
    margin: 0px;
    /* Replace 'path/to/left-column-image.jpg' with the actual path to your image */
    background-image: url("./dump\/20.jpg"), url("./dump\/20.jpg");
    /* Set the background image on the left and right side of the page */
    background-position: left top, right top;
    /* Make the background images repeat vertically to create the columns */
    background-repeat: repeat-y, repeat-y;
    /* Set the width of the left and right columns */
    background-size: 5vw auto, 5vw auto;
  }
  /* Center the main content wrapper horizontally */
  .wrapper {
    max-width: 800px;
    margin: 0 auto;
    /* Add some padding to create space between the columns and content */
    padding-left: 5vw;
    padding-right: 5vw;
  }
  canvas {
    position: absolute;
    left: 5vw;
    top: 0vh;
    width: 90vw;
    height: 100vh;
  }
</style>
